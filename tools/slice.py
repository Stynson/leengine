
from psd_tools import PSDImage
from PIL import Image, ImageChops
import pystache
import os, re, sys, codecs, argparse

c_template = r"""// hey, it's autogenerated! :)
#pragma once
#include "scene.h"

typedef struct scene_{{prefix}}_impl_t scene_{{prefix}}_impl_t;

struct scene_{{prefix}}_impl_t
{
	{{#entities}}
	{{#items}}
	scene_entity_t {{name}};
	{{/items}}
	scene_entity_t * entities[{{count}}];
	size_t entities_count; // TODO see if we can avoid this
	{{/entities}}

	{{#textures}}
	{{#items}}
	tex_t {{name}};
	{{/items}}
	tex_t * textures[{{count}}];
	size_t textures_count; // TODO see if we can avoid this
	{{/textures}}

	{{#sprites}}
	{{#items}}
	scene_sprite_t {{name}};
	{{/items}}
	scene_sprite_t * sprites[{{count}}];
	size_t sprites_count; // TODO see if we can avoid this
	{{/sprites}}

	{{#texts}}
	{{#items}}
	scene_text_t {{name}};
	{{/items}}
	scene_text_t * texts[{{count}}];
	size_t texts_count; // TODO see if we can avoid this
	{{/texts}}

	scene_t scene;
};

static void scene_{{prefix}}_load(scene_{{prefix}}_impl_t * s, scene_load_font_t load_font)
{
	memset(&s->scene, 0, sizeof(s->scene));

	{{#entities}}
	s->entities_count = {{count}};
	s->scene.entities_count = {{count}};
	s->scene.entities = s->entities;
	{{#items}}

	memset(&s->{{name}}, 0, sizeof(s->{{name}}));
	s->{{name}}.x          = {{x}};
	s->{{name}}.y          = {{y}};
	s->{{name}}.sx         = 1.0f;
	s->{{name}}.sy         = 1.0f;
	s->{{name}}.start_x    = {{x}};
	s->{{name}}.start_y    = {{y}};
	s->{{name}}.start_w    = {{w}};
	s->{{name}}.start_h    = {{h}};
	s->{{name}}.visible    = {{visible}};
	s->{{name}}.name       = "{{name}}";
	{{#sprite}}
	s->{{name}}.sprite     = &s->{{sprite_name}};
	{{/sprite}}
	{{#text}}
	s->{{name}}.text       = &s->{{text_name}};
	{{/text}}
	s->entities[{{index}}] = &s->{{name}};
	{{/items}}
	{{/entities}}


	{{#textures}}
	s->textures_count = {{count}};
	s->scene.textures_count = {{count}};
	s->scene.textures = s->textures;
	{{#items}}

	memset(&s->{{name}}, 0, sizeof(s->{{name}}));
	s->{{name}} = r_load("{{location}}/{{path}}", TEX_FLAGS_POINT);
	s->textures[{{index}}] = &s->{{name}};
	{{/items}}
	{{/textures}}

	{{#sprites}}
	s->sprites_count = {{count}};
	s->scene.sprites_count = {{count}};
	s->scene.sprites = s->sprites;
	{{#items}}

	memset(&s->{{name}}, 0, sizeof(s->{{name}}));
	s->{{name}}.entity    = &s->{{entity_name}};
	s->{{name}}.diffuse   = r_colorf(1.0f, 1.0f, 1.0f, 1.0f);
	memcpy(&s->{{name}}.tex, &s->{{texture_name}}, sizeof(tex_t));
	s->{{name}}.tex.w     = {{w}};
	s->{{name}}.tex.h     = {{h}};
	{{#uv}}
	s->{{name}}.tex.u1    = {{u1}}f;
	s->{{name}}.tex.v1    = {{v1}}f;
	s->{{name}}.tex.u2    = {{u2}}f;
	s->{{name}}.tex.v2    = {{v2}}f;
	{{/uv}}
	s->sprites[{{index}}] = &s->{{name}};
	{{/items}}
	{{/sprites}}

	{{#texts}}
	s->texts_count = {{count}};
	s->scene.texts_count = {{count}};
	s->scene.texts = s->texts;
	{{#items}}

	memset(&s->{{name}}, 0, sizeof(s->{{name}}));
	s->{{name}}.entity         = &s->{{entity_name}};
	s->{{name}}.text           = "{{text}}";
	s->{{name}}.font           = load_font("{{font}}");
	s->{{name}}.diffuse        = r_colorf(1.0f, 1.0f, 1.0f, 1.0f);
	s->{{name}}.size_in_pt     = {{size_in_pt}};
	s->{{name}}.shadow_x       = 1.0f;
	s->{{name}}.shadow_y       = -1.0f;
	s->{{name}}.shadow_diffuse = r_colorf(0.0f, 0.0f, 0.0f, 1.0f);
	s->texts[{{index}}] = &s->{{name}};
	{{/items}}
	{{/texts}}
}

"""

# helper class to get additional information from text layers
class PSDTextProps:
	def __init__(self, psd_layer):
		d = psd_layer._tagged_blocks.get(b'TySh') # gets psd_tools.decoder.tagged_blocks.TypeToolObjectSetting
		d = d[9] # gets psd_tools.decoder.actions.Descriptor
		d = d[2] # gets list
		d = d[7] # gets tuple
		d = d[1] # gets psd_tools.decoder.actions.RawData
		d = d[0] # gets bytes, aka raw text engine data from psd file
		self.raw_engine = d
		self.data = {}
		self._decode()

	@property
	def text(self):
		return self.data.get("text")

	@property
	def font(self):
		return self.data.get("font")

	@property
	def size(self):
		return self.data.get("size")

	def _decode(self):
		import io
		k = io.BytesIO(self.raw_engine)
		c = k.read(1)
		while c:
			if c == b'/':
				name = self._prop(k)
				if name == "Text":
					self.data["text"] = self._text(k).strip()
				elif name == "FontSet":
					self.data["font"] = self._text(k).strip()
				elif name == "FontSize":
					self.data["size"] = self._prop(k)
				#elif name == "Values": # TODO
				#	self.data["color"] = self._rgba(k)
			c = k.read(1)

	def _prop(self, k):
		c = k.read(1)
		name = b''
		while c != b' ' and c != b'\n' and c != b'\r' and c != b'\t' and c:
			name += c
			c = k.read(1)
		name = name.decode("utf-8")
		return name

	def _text(self, k):
		c = k.read(1)
		while c != b'(' and c:
			c = k.read(1)
		c = k.read(1)
		if c != b'\xfe':
			print("invalid psd text %x")
			return ""
		c = k.read(1)
		if c != b'\xff':
			print("invalid psd text")
			return ""
		c = k.read(1)
		text = ""
		while c != b')' and c:
			c1 = c
			c = k.read(1)
			if c == b'\\':
				c = k.read(1)
			if c == b'\n':
				text += "\n"
			else:
				val = ord(c1) << 8 | ord(c)
				#if val <= 255:
				text += chr(val)
				#else:
				#	text += '&#' + str(val) + ';'
			c = k.read(1)
		return text

	def _rgba(self, k):
		c = k.read(1)
		while c != b'[' and c:
			c = k.read(1)
		c = k.read(1)
		text = ""
		while c != b']' and c:
			text += chr(c[0])
			c = k.read(1)
		text = text.split()
		colors = [float(c) for c in text]
		return [colors[1], colors[2], colors[3], colors[0]]

class Slicer:
	def __init__(self):
		self.imgs = []
		self.idents = set()
		self.ignored_layers = set()
		self.images_output_folder = None
		self.images_scale_factor = 1.0
		self.scene_scale_factor = 1.0

	def _get_name(self, plane, parent_name):
		raw_name = plane.name if hasattr(plane, "name") else ""
		name = raw_name
		name = re.sub('[^0-9a-zA-Z_]', '', name) # now try to clean up name
		name = re.sub('^[^a-zA-Z_]+', '', name)
		if len(name) == 0: 
			name = "_unknown%i" % len(self.imgs) # generate a new name if it's empty
		name = (parent_name + "_" if len(parent_name) else parent_name) + name # add parent
		if name in self.idents: # add sufix if needed
			k = 0
			while name + "_" + str(k) in self.idents:
				k += 1
			name = name + "_" + str(k)
		return (raw_name, name)

	def _cache_images(self, filename, img):
		name = "texture_%i" % len(self.textures)
		if self.images_cache == None:
			self.textures.append({"path": filename, "name": name, "index": len(self.textures), "img": img})
			return name

		w, h = img.size
		key = "%i_%i" % (w, h)
		cached = self.images_cache.get(key, [])

		import math
		import functools
		histogram = img.histogram()
		for el in cached:
			h1 = histogram
			h2 = el[3]
			rms = math.sqrt(functools.reduce(lambda a, b: a + b, map(lambda a, b: (a - b) ** 2, h1, h2)) / len(h1))
			if rms == 0.0 and ImageChops.difference(img, el[2]).getbbox() is None:
				print("replacing '%s' with '%s'" % (filename, el[1]))
				return el[0]

		cached.append((name, filename, img, histogram))
		self.images_cache[key] = cached
		self.textures.append({"path": filename, "name": name, "index": len(self.textures), "img": img})
		return name

	def _export(self, plane, parent_name = "", parent_visible = True):
		raw_name, name = self._get_name(plane, parent_name)
		if raw_name in self.ignored_layers: # first check if it's ignored
			return
		self.idents.add(name)
		if hasattr(plane, "layers"):
			for layer in plane.layers:
				self._export(layer, name if raw_name else parent_name, parent_visible and layer.visible)
		else:
			# create an entity
			ent = {
				"index": len(self.entities),
				"name": name,
				"x": self.scene_scale_factor * (plane.bbox.x1 + plane.bbox.width / 2),
				"y": self.scene_scale_factor * (- plane.bbox.height / 2 - plane.bbox.y1),
				"w": self.scene_scale_factor * plane.bbox.width,
				"h": self.scene_scale_factor * plane.bbox.height,
				"visible": "true" if parent_visible and plane.visible else "false",
			}
		
			if plane.text_data:
				# create text component
				txt_name = "txt_" + name

				props = PSDTextProps(plane)

				self.texts.append({
					"index": len(self.texts),
					"name": txt_name,
					"entity_name": name,
					"text": props.text,
					"font": props.font,
					"size_in_pt": props.size,
				})

				ent["text"] = {"text_name": txt_name}
			else:
				try:
					spr_name = "spr_" + name
					filename = name + ".png"

					img = plane.as_PIL()
					img = img.resize([int(self.images_scale_factor * s) for s in img.size])
					texture_name = self._cache_images(filename, img)

					self.sprites.append({
						"index": len(self.sprites),
						"name": spr_name,
						"entity_name": name,
						"texture_name": texture_name,
						"w": ent["w"],
						"h": ent["h"]
					})

					ent["sprite"] = {"sprite_name": spr_name}
				except:
					print("unexpected error while saving the sprite %s:" % (name), sys.exc_info()[0])

			self.entities.append(ent)

	def _pack_test(self):
		if len(self.textures) == 0:
			return

		from packer import PackingRectangle, Packer

		# prepare rects
		rects = []
		rects2 = {}
		for texture in self.textures:
			r = PackingRectangle()
			r.size = texture.get("img").size
			rects.append(r)
			rects2[r] = (texture.get("name"), texture.get("img"))

		# pack
		packer = Packer(rects)
		res, area = packer.pack()
		uvs = {}
		w = 0
		h = 0
		for e in res:
			w = max(w, e.right)
			h = max(h, e.bottom)
		for e in res:
			rect = e.rect
			uvs[rects2.get(e)[0]] = (rect[0] / float(w), rect[1] / float(h), rect[2] / float(w), rect[3] / float(h)) # u1, v1, u2, v2
		print("packed into", w, h)

		# generate new image
		img = Image.new('RGBA', (w, h))
		for e in res:
			img.paste(rects2.get(e)[1], e.position)
		self.textures = [{"path": "atlas.png", "name": "texture_atlas", "index": 0, "img": img}]

		for spr in self.sprites:
			uv = uvs.get(spr["texture_name"])
			spr["uv"] = {"u1": float(uv[0]), "v1": float(uv[1]), "u2": float(uv[2]), "v2": float(uv[3])}
			spr["texture_name"] = "texture_atlas"

	def _save_images(self):
		for texture in self.textures:
			texture.get("img").save(os.path.join(self.images_output_folder, texture.get("path")))

	def slice(self, prefix, psd_filename, images_output_folder, source_output_folder, images_path_from_source, images_scale_factor = 1.0, scene_scale_factor = 1.0, ignored_layers = set(), enable_cache = True, atlas_packing = False):
		self.entities = []
		self.sprites = []
		self.texts = []
		self.textures = []
		self.idents = set()
		self.images_cache = {} if enable_cache else None
		self.images_output_folder = images_output_folder
		self.images_scale_factor = images_scale_factor
		self.scene_scale_factor = scene_scale_factor
		self.ignored_layers = ignored_layers

		try:
			os.mkdir(images_output_folder)
		except:
			pass

		try:
			os.mkdir(source_output_folder)
		except:
			pass

		plane = PSDImage.load(psd_filename)
		if not plane:
			raise ValueError("failed to load %s" % psd_filename)
		self._export(plane)

		if atlas_packing:
			self._pack_test() # experimental atlas support

		self._save_images()

		self.entities.reverse()
		for ent in self.entities:
			ent["index"] = len(self.entities) - ent["index"] - 1

		data = {
			"prefix": prefix,
			"location": images_path_from_source,
		}

		if len(self.entities):
			data["entities"] = {"items": self.entities, "count": len(self.entities)}

		if len(self.sprites):
			data["sprites"] = {"items": self.sprites, "count": len(self.sprites)}

		if len(self.textures):
			data["textures"] = {"items": self.textures, "count": len(self.textures)}

		if len(self.texts):
			data["texts"] = {"items": self.texts, "count": len(self.texts)}

		with codecs.open(os.path.join(source_output_folder, "%s_scene.h" % prefix), "w", "utf-8") as f:
			f.write(pystache.render(c_template, data))

parser = argparse.ArgumentParser(description = "Slice dat psd good yolo")
parser.add_argument("-p", "--psd",	required = True, help = "input psd file")
parser.add_argument("-n", "--name",	required = True, help = "prefix identifier name for the source")
parser.add_argument("-i", "--imgs",	required = True, help = "directory where to put images")
parser.add_argument("-s", "--src",	required = True, help = "directory where to put source")
parser.add_argument("-r", "--rel",	required = True, help = "relative path from source code to images")
parser.add_argument("-t", "--scale", default = 1.0, type = float, help = "scale factor for images")
parser.add_argument("-z", "--scene-scale", default = 1.0, type = float, help = "scale factor for the scene")
parser.add_argument("--ignore", action = "append", default = [], help = "ignore layer with name")
parser.add_argument("--cache", default = False, type = bool, help = "use caching to ignore duplicates")
parser.add_argument("--pack", default = False, type = bool, help = "experimental atlas packing")
args = vars(parser.parse_args())

Slicer().slice(
	prefix					= args.get("name"),
	psd_filename			= args.get("psd"),
	images_output_folder	= args.get("imgs"),
	source_output_folder	= args.get("src"),
	images_path_from_source	= args.get("rel"),
	images_scale_factor		= args.get("scale"),
	scene_scale_factor		= args.get("scene_scale"),
	ignored_layers			= set(args.get("ignore")),
	enable_cache			= args.get("cache"),
	atlas_packing			= args.get("pack")
)
