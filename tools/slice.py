
from psd_tools import PSDImage
import pystache
import os, re, sys, codecs, argparse

c_template = r"""// hey, it's autogenerated! :)
#pragma once
#include "render.h"

typedef struct {{prefix}}_scene_t {{prefix}}_scene_t;
typedef void (*{{prefix}}_scene_callback)({{prefix}}_scene_t * scene);

struct {{prefix}}_scene_t
{
	{{#imgs}}
	struct
	{
		tex_t tex;
		float x, y, r, sx, sy, ox, oy;
		float start_x, start_y; // original position of an object
		bool visible;
		float diffuse_r, diffuse_g, diffuse_b, diffuse_a;
		{{prefix}}_scene_callback callback;
	} {{name}};
	{{/imgs}}
	void * userdata;
};

static void {{prefix}}_load({{prefix}}_scene_t * s)
{
	{{#imgs}}
	s->{{name}}.tex = r_load("{{location}}/{{path}}", TEX_FLAGS_NONE);
	s->{{name}}.x = {{x}};
	s->{{name}}.y = {{y}};
	s->{{name}}.r = 0.0f;
	s->{{name}}.sx = 1.0f;
	s->{{name}}.sy = 1.0f;
	s->{{name}}.ox = 0.0f;
	s->{{name}}.oy = 0.0f;
	s->{{name}}.start_x = {{x}};
	s->{{name}}.start_y = {{y}};
	s->{{name}}.visible = {{visible}};
	s->{{name}}.diffuse_r = 1.0f;
	s->{{name}}.diffuse_g = 1.0f;
	s->{{name}}.diffuse_b = 1.0f;
	s->{{name}}.diffuse_a = 1.0f;
	{{/imgs}}
}

static void {{prefix}}_free({{prefix}}_scene_t * s)
{
	{{#imgs}}
	r_free(s->{{name}}.tex);
	{{/imgs}}
}

{{#imgs}}
static void {{prefix}}_draw_{{name}}({{prefix}}_scene_t * s)
{
	r_render_ex2(
		s->{{name}}.tex,
		s->{{name}}.x,
		s->{{name}}.y,
		s->{{name}}.r,
		s->{{name}}.sx,
		s->{{name}}.sy,
		s->{{name}}.ox,
		s->{{name}}.oy,
		s->{{name}}.diffuse_r,
		s->{{name}}.diffuse_g,
		s->{{name}}.diffuse_b,
		s->{{name}}.diffuse_a
	);
}
{{/imgs}}

static void {{prefix}}_draw({{prefix}}_scene_t * s)
{
	{{#imgs}}
	if(s->{{name}}.callback) s->{{name}}.callback(s);
	if(s->{{name}}.visible)  {{prefix}}_draw_{{name}}(s);
	{{/imgs}}
}
"""

class Slicer:
	def __init__(self):
		self.imgs = []
		self.idents = set()
		self.ignored_layers = set()
		self.images_output_folder = None
		self.images_scale_factor = 1.0
		self.scene_scale_factor = 1.0

	def _get_name(self, plane, parent_name):
		raw_name = plane.name if hasattr(plane, "name") else ""
		name = raw_name
		name = re.sub('[^0-9a-zA-Z_]', '', name) # now try to clean up name
		name = re.sub('^[^a-zA-Z_]+', '', name)
		if len(name) == 0: 
			name = "_unknown%i" % len(self.imgs) # generate a new name if it's empty
		name = parent_name + name # add parent
		if name in self.idents: # add sufix if needed
			k = 0
			while name + "_" + str(k) in self.idents:
				k += 1
			name = name + "_" + str(k)
		return (raw_name, name)

	def _export(self, plane, parent_name = ""):
		raw_name, name = self._get_name(plane, parent_name)
		if raw_name in self.ignored_layers: # first check if it's ignored
			return
		self.idents.add(name)
		if hasattr(plane, "layers"):
			for layer in plane.layers:
				self._export(layer, name if raw_name else parent_name)
		else:
			try:
				filename = name + ".png"

				img = plane.as_PIL()
				img = img.resize([int(self.images_scale_factor * s) for s in img.size])
				img.save(os.path.join(self.images_output_folder, filename))

				self.imgs.append({
					"x": self.scene_scale_factor * (plane.bbox.x1 + plane.bbox.width / 2),
					"y": self.scene_scale_factor * (- plane.bbox.height / 2 - plane.bbox.y1),
					"w": self.scene_scale_factor * plane.bbox.width,
					"h": self.scene_scale_factor * plane.bbox.height,
					"name": name,
					"path": filename,
					"visible": "true" if plane.visible else "false"
				})
			except Exception as e:
				print("failed to save image '%s' because '%s'" % (filename, str(e)))

	def slice(self, prefix, psd_filename, images_output_folder, source_output_folder, images_path_from_source, images_scale_factor = 1.0, scene_scale_factor = None, ignored_layers = set()):
		self.imgs = []
		self.idents = set()
		self.images_output_folder = images_output_folder
		self.images_scale_factor = images_scale_factor
		self.scene_scale_factor = scene_scale_factor if scene_scale_factor else images_scale_factor
		self.ignored_layers = ignored_layers

		try:
			os.mkdir(images_output_folder)
		except:
			pass

		try:
			os.mkdir(source_output_folder)
		except:
			pass

		plane = PSDImage.load(psd_filename)
		if not plane:
			raise ValueError("failed to load %s" % psd_filename)
		self._export(plane)
		self.imgs.reverse()

		data = {
			"prefix": prefix,
			"location": images_path_from_source,
			"imgs": self.imgs
		}
		with codecs.open(os.path.join(source_output_folder, "%s_scene.h" % prefix), "w", "utf-8") as f:
			f.write(pystache.render(c_template, data))

parser = argparse.ArgumentParser(description = "Slice dat psd good yolo")
parser.add_argument("-p", "--psd",  required = True, help = "input psd file")
parser.add_argument("-n", "--name", required = True, help = "prefix identifier name for the source")
parser.add_argument("-i", "--imgs", required = True, help = "directory where to put images")
parser.add_argument("-s", "--src",  required = True, help = "directory where to put source")
parser.add_argument("-r", "--rel",  required = True, help = "relative path from source code to images")
parser.add_argument("-t", "--scale", default = 1.0, type = float, help = "scale factor for images")
parser.add_argument("-z", "--scene-scale", type = float, help = "scale factor for the scene")
parser.add_argument("--ignore", action = "append", default = [], help = "ignore layer with name")
args = vars(parser.parse_args())

Slicer().slice(
	args.get("name"),
	args.get("psd"),
	args.get("imgs"),
	args.get("src"),
	args.get("rel"),
	args.get("scale"),
	args.get("scene_scale"),
	set(args.get("ignore")))
