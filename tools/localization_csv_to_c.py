
import sys


if sys.version_info < (3, 0):
	reload(sys)
	sys.setdefaultencoding('utf-8')

import csv, pystache, argparse, codecs, os

c_template = r"""// hey, it's autogenerated! :)
#include "{{header_filename}}"
#include <string.h>

static lang_t _lang = lang_invalid;
void loc_set(lang_t lang) {_lang = lang;}

const char * loc(const char * key)
{
{{#strings}}
	if(!strcmp(key, "%{{name}}%")) return loc_{{name}}();
{{/strings}}
	return NULL;
}

{{#strings}}
const char * loc_{{name}}()
{
	switch(_lang)
	{
	{{#data}}
	case lang_{{lang}}: return "{{text}}";
	{{/data}}
	default: return "%{{name}}%";
	}
}

{{/strings}}
"""

h_template = r"""// hey, it's autogenerated! :)
#pragma once

typedef enum
{
	lang_invalid = 0,
{{#languages}}
	lang_{{name}},
{{/languages}}
	lang_max
} lang_t;

void loc_set(lang_t lang);
const char * loc(const char * key);

{{#strings}}
const char * loc_{{name}}();
{{/strings}}
"""

def form_dict(settings, data, header_filename):
	langs = [
		{
			'name': name
		}
		for name in settings[1]
	]
	strings = [
		{
			'name': label[0],
			'data':
			[
				{
					'lang': settings[1][i],
					'text': text
				}
				for i, text in enumerate(label[1])
			]
		}
		for label in data if len(label[0])
	]
	return {'languages': langs, 'strings': strings, 'header_filename': header_filename}

parser = argparse.ArgumentParser(description='localization csv to c+h files')
parser.add_argument('-i', '--in',	required=True, help='input csv file')
parser.add_argument('-o', '--out',	nargs='+', help='output c and h files')
args = vars(parser.parse_args())

in_csv = args.get('in')
out_c = None
out_h = None
for name in args.get('out'):
	if name.endswith('.c'):
		out_c = name
	elif name.endswith('.h'):
		out_h = name

data = {}
with codecs.open(in_csv, mode='r', encoding='utf8') as csvfile:
	rows = [(row[0], row[1:]) for row in csv.reader(csvfile, delimiter=',', quotechar='|')]
	data = form_dict(rows[1], rows[2:], os.path.split(out_h)[1])

with codecs.open(out_c, 'w', 'utf-8') as f:
	f.write(pystache.render(c_template, data))

with codecs.open(out_h, 'w', 'utf-8') as f:
	f.write(pystache.render(h_template, data))
